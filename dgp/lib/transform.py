# coding=utf-8

"""
transform.py
Library for data transformation classes
"""

from copy import deepcopy
from pandas import DataFrame
import inspect
from functools import wraps

from dgp.lib.etc import gen_uuid, dedup_dict


transform_registry = {}


def createtransform(func):
    """
    Function decorator that generates a transform class for the decorated
    function.

    This decorator is an alternative to defining a subclass of Transform.
    The class generated by this decorator is automatically inserted into the
    transform registry.

    Positional arguments are reserved for data.
    Required keyword arguments are made into attributes of the class.

    Returns
    -------
    Transform
        A callable instance of a class that subclasses Transform
    """

    def class_func(self, *args, **kwargs):
        return func(*args, **kwargs)

    sig = inspect.signature(func)
    var_list = []

    for param in sig.parameters.values():
        if param.kind == param.KEYWORD_ONLY:
            if param.default is not param.empty:
                var_list.append((param.name, param.default))
            else:
                var_list.append(param.name)

    class_id = func.__name__
    cls = type(class_id, (Transform,),
               dict(func=class_func, var_list=var_list))
    transform_registry[class_id] = cls

    @wraps(func)
    def wrapper(*args, **kwargs):
        return cls(*args, **kwargs)

    return wrapper


# class RegisterTransformClass:
#     """
#     Class decorator for constructing transforms. Use the decorator when
#     defining transform classes to submit the transform into the registry.
#
#     class_id is the name of the decorated class.
#     """
#     def __init__(self):
#         pass
#
#     def __call__(self, cls):
#         class_id = cls.__name__
#         if class_id in transform_registry:
#             raise KeyError('Transform class {cls} already exists in registry.'
#                            .format(cls=class_id))
#
#         transform_registry[class_id] = cls
#         return cls
#
#     @staticmethod
#     def get_class_from_id(class_id):
#         return transform_registry.get(class_id)


def registertransformclass(cls):
    """
    Class decorator for constructing transform classes.

    The decorator adds an entry for the decorated class into the transform
    class registry.
    """
    class_id = cls.__name__
    if class_id in transform_registry:
        raise KeyError('Transform class {cls} already exists in registry.'
                       .format(cls=class_id))

    transform_registry[class_id] = cls
    return cls


class Transform:
    """
    Transform base class.

    All transform classes should subclass this one.

    The class instance is callable. Any parameters not specified when called
    are filled in by the values set in the instance variables that correspond
    with those parameters. Instance variables are specified in the variable
    `var_list`.

    `var_list` is a list of attribute names as strings. If an attribute
    has a default value, then specify as a tuple: ('var_name', default_value)
    If no default value is given, then the variable is initialized with the
    the value `None`.

    Default values for attributes in var_list can be overridden with keyword
    arguments when instantiating the class.

    The same transform with different parameters can be generated by making a
    new instance and setting the instance variables accordingly.

    Each instance is given a unique id.

    """
    # TODO: Replace var_list with inspection of function signature?
    var_list = None

    def __init__(self, **kwargs):
        self._uid = gen_uuid('tf')
        if self.var_list is None:
            raise ValueError('Must set `var_list` variable. (class={cls})'
                             .format(cls=self.__class__.__name__))

        for var in self.var_list:
            if isinstance(var, tuple):
                name, val = var
            else:
                name = var
                val = None

            if getattr(self, name, None) is None:
                setattr(self, name, val)

        for k, v in kwargs.items():
            if getattr(self, name, None) is not None:
                setattr(self, k, v)

    @property
    def uid(self):
        return self._uid

    def __call__(self, *args, **kwargs):
        keywords = {}
        for arg in self.var_list:
            if isinstance(arg, tuple):
                name = arg[0]
            else:
                name = arg

            keywords[name] = self.__dict__[name]

        # override keywords explicitly set in function call
        for k, v in kwargs.items():
            keywords[k] = v

        return self.func(*args, **keywords)

    def __str__(self):
        attrs = ', '.join(['{var}={val}'.format(var=k, val=v)
                           for k, v in self.__dict__.items() if k != '_uid'])
        return '{cls}({attrs})'.format(cls=self.__class__.__name__,
                                       attrs=attrs)


# TODO: Subclass an ordered dict?
class TransformChain:
    def __init__(self):
        self._uid = gen_uuid('tc')
        self._transforms = {}
        self._ordering = []

    @property
    def uid(self):
        return self._uid

    @property
    def ordering(self):
        return self._ordering

    # TODO: Do not accept functions in the future.
    # TODO: Check persistence of the transform object after the original is garbage collected.
    def addtransform(self, transform):
        if callable(transform):
            if hasattr(transform, 'uid'):
                uid = transform.uid
            else:
                uid = gen_uuid('tf')
            self._transforms[uid] = transform
            self._ordering.append(uid)

    def removetransform(self, uid):
        del self._transforms[uid]
        self._ordering.remove(uid)

    def reorder(self, reordering):
        """
        Change the order of application of transforms. Input is a dictionary
        with transform uid's as keys and position as values.
        """
        d = dedup_dict(reordering)
        order = sorted(d.keys(), key=d.__getitem__)
        for uid in order:
            self._ordering.remove(uid)
            self._ordering.insert(d[uid], uid)
        return self.ordering

    # TODO: Implement splitting of kwargs amongst transforms in the chain. What if there are multiple transforms with the same signature?
    # TODO: Accommodate multiple positional arguments. Now this only handles one.
    def apply(self, df):
        """
        Makes a deep copy of the target DataFrame and applies the transforms in
        the order specified.
        """
        df_cp = deepcopy(df)
        for uid in self._ordering:
            df_cp = self._transforms[uid](df_cp)
        return df_cp

    def __len__(self):
        return len(self._transforms.items())

    def __str__(self):
        transforms = ', '.join([str(self._transforms[uid])
                                for uid in self._ordering])
        return 'TransformChain({transforms})'.format(transforms=transforms)

    def __getitem__(self, key):
        return self._ordering[key]

    def __iter__(self):
        for uid in self._ordering:
            yield self._transforms[uid]


class DataWrapper:
    """
    A container for transformed DataFrames. Multiple transform chains may
    be specified and the resultant DataFrames will be held in this class
    instance.
    """
    def __init__(self, frame: DataFrame):
        self.df = frame # original DataFrame; not ever modified
        self.modified = {}
        self._transform_chains = {}
        self._defaultchain = None

    def removechain(self, uid):
        del self._transform_chains[uid]
        del self.modified[uid]

    def applychain(self, tc):
        if not isinstance(tc, TransformChain):
            raise TypeError('expected an instance or subclass of '
                            'TransformChain, but got {typ}'
                            .format(typ=type(tc)))

        if tc.uid not in self._transform_chains:
            self._transform_chains[tc.uid] = tc
            if self._defaultchain is None:
                self._defaultchain = self._transform_chains[tc.uid]
        self.modified[tc.uid] = self._transform_chains[tc.uid].apply(self.df)
        return self.modified[tc.uid]

    @property
    def data(self, reapply=False):
        if self._defaultchain is not None:
            if reapply:
                return self.applychain(self._defaultchain)
            else:
                return self.modified[self._defaultchain.uid]
        else:
            return self.df

    def __len__(self):
        return len(self.modified.items())
